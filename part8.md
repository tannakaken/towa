# テーブルのフォーマットによる比較

現在の「順番になっていない行の配列（メタデータなし）」は、
行のみを保存しているので、空間的な効率はとても高いです。
挿入もとても早いです。全体の後ろに付け足しているだけなので。
しかし、特定の行を探すためには、見つかるまで全ての行を順番に調べていく必要があります。
行の数を$n$とすると、これには平均的に$\frac{n}{2}$の比較操作が必要になります。
また、行を削除しようと思うと、できた穴を埋めるために、削除された行以降の行を全て1行ずつ前に移動させる必要があります。
これにも平均的に$\frac{n}{2}$のコピー操作が必要になります。

もし「順番になった行の配列」として保存したならば、
特定の行を探すために、二分探索が使えるので、必要な比較操作のオーダーは$\Theta(\log(n))$になります。
しかし挿入のたびに挿入された行より後ろの行を移動させる必要ができたので、平均的に$\frac{n}{2}$のコピー操作が必要になってしまいました。
削除に関しても同じです。

今回実装するB+木をはじめとした木構造ではどうなるでしょう。
木の中の全てのノードは様々な数の行を含むことができます。
よってノードは幾つの行を含んでいるかなどの追加の情報を持つ必要があります。
さらに、全く行を含まない内部ノードを持つ必要もあります。
その代わりに、もっと大きなデータベースでは、より早く挿入, 削除, 検索をこなすことができるのです。


||順番になっていない行の配列|順番になった行の配列|ノードの木|
| ---- | ---- | ---- | ---- |
|ページに含まれるもの|データのみ|データのみ|メタデータ, 主キー, データ|
|1ページあたりの行|多い|多い|少ない|
|挿入|$O(1)$|$O(n)$|$O(\log(n))$|
|削除|$O(n)$|$O(n)$|$O(\log(n))$|
|idによる検索|$O(n)$|$O(\log(n))$|$O(\log(n))$|

